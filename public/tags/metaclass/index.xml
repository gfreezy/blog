<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>metaclass on allsunday</title><link>http://blog.allsunday.io/tags/metaclass/</link><description>Recent content in metaclass on allsunday</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 09 Nov 2014 00:00:00 +0000</lastBuildDate><atom:link href="http://blog.allsunday.io/tags/metaclass/index.xml" rel="self" type="application/rss+xml"/><item><title>Python 多继承下 metaclass 优先级</title><link>http://blog.allsunday.io/post/2014-11-09-python-mutiple-metaclass/</link><pubDate>Sun, 09 Nov 2014 00:00:00 +0000</pubDate><guid>http://blog.allsunday.io/post/2014-11-09-python-mutiple-metaclass/</guid><description>在 Python 里面，class 也是一个对象，它是 type 实例化后生成的对象。 我们一般用如下的代码来定义一个类。
class ClassA(object): def method1(self): pass @classmethod def method2(cls): pass 实际上 class 这个关键字是类似语法糖一样的东西。 上面的 class 定义等价为
def method1(self): pass @classmethod def method2(cls): pass attrs = { 'method1': method1, 'method2': method2, } ClassA = type('ClassA', (object,), attrs) type 的三个参数分别为：
类的名字（ ClassA.__name__ 中存储的名字),
继承的父类(可以是多个父类),
类的所有属性（类的各种方法和属性）。
以上是一个未指定 __metaclass__ 的 class 的生成过程。 但是在 ORM 的代码中，经常可以看到类似这样的写法</description></item></channel></rss>